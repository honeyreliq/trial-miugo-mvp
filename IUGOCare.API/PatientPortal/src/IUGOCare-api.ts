/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

export interface IAuthenticationClient {
    getAuth0AuthenticationSettings(): Promise<FileResponse>;
}

export class AuthenticationClient implements IAuthenticationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAuth0AuthenticationSettings(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Authentication/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetAuth0AuthenticationSettings(_response);
        });
    }

    protected processGetAuth0AuthenticationSettings(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export interface ICommandTestsClient {
    getPatients(filter: PatientQueryFilter): Promise<PatientsVm>;
    patientAcceptsToS(command: PatientAcceptsToSCommand): Promise<FileResponse>;
    registerPatient(command: RegisterPatientCommand): Promise<FileResponse>;
    sendPatientOnboardingEmail(command: SendPatientOnboardingEmailCommand): Promise<FileResponse>;
    enableMarketingEmails(command: EnableMarketingEmailsCommand): Promise<FileResponse>;
    disableMarketingEmails(command: DisableMarketingEmailsCommand): Promise<FileResponse>;
    updateEmailAddress(command: UpdateEmailAddressCommand): Promise<Unit>;
    createObservation(command: CreateObservationCommand): Promise<Unit>;
    updateObservation(command: UpdateObservationCommand): Promise<string>;
    getCareManagementPrograms(): Promise<CareManagementProgramsVm>;
    createOrganization(command: CreateOrganizationCommand): Promise<FileResponse>;
    getOrganizations(): Promise<OrganizationsVm>;
    setPatientCareMangementProgramEnrollment(command: SetPatientCareManagementProgramEnrollmentCommand): Promise<FileResponse>;
    createProvider(command: CreateProviderCommand): Promise<FileResponse>;
    getProviders(): Promise<ProvidersVm>;
}

export class CommandTestsClient implements ICommandTestsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getPatients(filter: PatientQueryFilter): Promise<PatientsVm> {
        let url_ = this.baseUrl + "/api/CommandTests/patients/{filter}";
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined.");
        url_ = url_.replace("{filter}", encodeURIComponent("" + filter));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetPatients(_response);
        });
    }

    protected processGetPatients(response: AxiosResponse): Promise<PatientsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PatientsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PatientsVm>(<any>null);
    }

    patientAcceptsToS(command: PatientAcceptsToSCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/CommandTests/PatientAcceptsToS";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processPatientAcceptsToS(_response);
        });
    }

    protected processPatientAcceptsToS(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    registerPatient(command: RegisterPatientCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/CommandTests/patient/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRegisterPatient(_response);
        });
    }

    protected processRegisterPatient(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    sendPatientOnboardingEmail(command: SendPatientOnboardingEmailCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/CommandTests/SendPatientOnboardingEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSendPatientOnboardingEmail(_response);
        });
    }

    protected processSendPatientOnboardingEmail(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    enableMarketingEmails(command: EnableMarketingEmailsCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/CommandTests/EnableMarketingEmails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processEnableMarketingEmails(_response);
        });
    }

    protected processEnableMarketingEmails(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    disableMarketingEmails(command: DisableMarketingEmailsCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/CommandTests/DisableMarketingEmails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDisableMarketingEmails(_response);
        });
    }

    protected processDisableMarketingEmails(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    updateEmailAddress(command: UpdateEmailAddressCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/CommandTests/patient/updateemailaddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdateEmailAddress(_response);
        });
    }

    protected processUpdateEmailAddress(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    createObservation(command: CreateObservationCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/CommandTests/CreateObservation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreateObservation(_response);
        });
    }

    protected processCreateObservation(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    updateObservation(command: UpdateObservationCommand): Promise<string> {
        let url_ = this.baseUrl + "/api/CommandTests/updateObservation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdateObservation(_response);
        });
    }

    protected processUpdateObservation(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    getCareManagementPrograms(): Promise<CareManagementProgramsVm> {
        let url_ = this.baseUrl + "/api/CommandTests/careManagementPrograms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetCareManagementPrograms(_response);
        });
    }

    protected processGetCareManagementPrograms(response: AxiosResponse): Promise<CareManagementProgramsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CareManagementProgramsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CareManagementProgramsVm>(<any>null);
    }

    createOrganization(command: CreateOrganizationCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/CommandTests/createOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreateOrganization(_response);
        });
    }

    protected processCreateOrganization(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getOrganizations(): Promise<OrganizationsVm> {
        let url_ = this.baseUrl + "/api/CommandTests/organizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetOrganizations(_response);
        });
    }

    protected processGetOrganizations(response: AxiosResponse): Promise<OrganizationsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationsVm>(<any>null);
    }

    setPatientCareMangementProgramEnrollment(command: SetPatientCareManagementProgramEnrollmentCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/CommandTests/setPatientCareManagementProgramEnrollment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSetPatientCareMangementProgramEnrollment(_response);
        });
    }

    protected processSetPatientCareMangementProgramEnrollment(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    createProvider(command: CreateProviderCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/CommandTests/createProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreateProvider(_response);
        });
    }

    protected processCreateProvider(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getProviders(): Promise<ProvidersVm> {
        let url_ = this.baseUrl + "/api/CommandTests/providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetProviders(_response);
        });
    }

    protected processGetProviders(response: AxiosResponse): Promise<ProvidersVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProvidersVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProvidersVm>(<any>null);
    }
}

export interface IObservationsClient {
    getPatientObservations(clinicPatientId: string | undefined, observationCodes: string[] | null | undefined, effectiveDateStart: Date | undefined, effectiveDateEnd: Date | undefined): Promise<PatientObservationsVm>;
    createManualObservation(command: CreateManualObservationCommand): Promise<FileResponse>;
    getRecentPatientObservationTypes(): Promise<RecentPatientObservationTypesVm>;
}

export class ObservationsClient implements IObservationsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getPatientObservations(clinicPatientId: string | undefined, observationCodes: string[] | null | undefined, effectiveDateStart: Date | undefined, effectiveDateEnd: Date | undefined): Promise<PatientObservationsVm> {
        let url_ = this.baseUrl + "/api/Observations/filter?";
        if (clinicPatientId === null)
            throw new Error("The parameter 'clinicPatientId' cannot be null.");
        else if (clinicPatientId !== undefined)
            url_ += "clinicPatientId=" + encodeURIComponent("" + clinicPatientId) + "&";
        if (observationCodes !== undefined)
            observationCodes && observationCodes.forEach(item => { url_ += "observationCodes=" + encodeURIComponent("" + item) + "&"; });
        if (effectiveDateStart === null)
            throw new Error("The parameter 'effectiveDateStart' cannot be null.");
        else if (effectiveDateStart !== undefined)
            url_ += "effectiveDateStart=" + encodeURIComponent(effectiveDateStart ? "" + effectiveDateStart.toJSON() : "") + "&";
        if (effectiveDateEnd === null)
            throw new Error("The parameter 'effectiveDateEnd' cannot be null.");
        else if (effectiveDateEnd !== undefined)
            url_ += "effectiveDateEnd=" + encodeURIComponent(effectiveDateEnd ? "" + effectiveDateEnd.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetPatientObservations(_response);
        });
    }

    protected processGetPatientObservations(response: AxiosResponse): Promise<PatientObservationsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PatientObservationsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PatientObservationsVm>(<any>null);
    }

    createManualObservation(command: CreateManualObservationCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Observations/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreateManualObservation(_response);
        });
    }

    protected processCreateManualObservation(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getRecentPatientObservationTypes(): Promise<RecentPatientObservationTypesVm> {
        let url_ = this.baseUrl + "/api/Observations/recentPatientObservationTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetRecentPatientObservationTypes(_response);
        });
    }

    protected processGetRecentPatientObservationTypes(response: AxiosResponse): Promise<RecentPatientObservationTypesVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RecentPatientObservationTypesVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RecentPatientObservationTypesVm>(<any>null);
    }
}

export interface IPatientsClient {
    getPatients(filter: PatientQueryFilter): Promise<PatientsVm>;
    getPatient(): Promise<PatientVm>;
    activatePatient(command: PatientAcceptsToSCommand): Promise<FileResponse>;
    enableMarketingEmails(command: EnableMarketingEmailsCommand): Promise<FileResponse>;
    updatePatientPreferences(command: UpdatePatientPreferencesCommand): Promise<FileResponse>;
    updateEmail(command: PatientRequestUpdateEmailCommand): Promise<Result>;
    getEmailToken(token: string | null): Promise<EmailTokenVm>;
    useEmailToken(token: string | null): Promise<FileResponse>;
    getPatientProfile(): Promise<PatientProfileVm>;
    updatePassword(command: UpdatePasswordCommand): Promise<Result>;
}

export class PatientsClient implements IPatientsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getPatients(filter: PatientQueryFilter): Promise<PatientsVm> {
        let url_ = this.baseUrl + "/api/Patients/patients/{filter}";
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined.");
        url_ = url_.replace("{filter}", encodeURIComponent("" + filter));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetPatients(_response);
        });
    }

    protected processGetPatients(response: AxiosResponse): Promise<PatientsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PatientsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PatientsVm>(<any>null);
    }

    getPatient(): Promise<PatientVm> {
        let url_ = this.baseUrl + "/api/Patients/patient";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetPatient(_response);
        });
    }

    protected processGetPatient(response: AxiosResponse): Promise<PatientVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PatientVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PatientVm>(<any>null);
    }

    activatePatient(command: PatientAcceptsToSCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Patients/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processActivatePatient(_response);
        });
    }

    protected processActivatePatient(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    enableMarketingEmails(command: EnableMarketingEmailsCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Patients/enableMarketingEmails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processEnableMarketingEmails(_response);
        });
    }

    protected processEnableMarketingEmails(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    updatePatientPreferences(command: UpdatePatientPreferencesCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Patients/updatePatientPreferences";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdatePatientPreferences(_response);
        });
    }

    protected processUpdatePatientPreferences(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    updateEmail(command: PatientRequestUpdateEmailCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Patients/updateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdateEmail(_response);
        });
    }

    protected processUpdateEmail(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(<any>null);
    }

    getEmailToken(token: string | null): Promise<EmailTokenVm> {
        let url_ = this.baseUrl + "/api/Patients/updateEmail/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetEmailToken(_response);
        });
    }

    protected processGetEmailToken(response: AxiosResponse): Promise<EmailTokenVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EmailTokenVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EmailTokenVm>(<any>null);
    }

    useEmailToken(token: string | null): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Patients/updateEmail/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUseEmailToken(_response);
        });
    }

    protected processUseEmailToken(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getPatientProfile(): Promise<PatientProfileVm> {
        let url_ = this.baseUrl + "/api/Patients/patient/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetPatientProfile(_response);
        });
    }

    protected processGetPatientProfile(response: AxiosResponse): Promise<PatientProfileVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PatientProfileVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PatientProfileVm>(<any>null);
    }

    updatePassword(command: UpdatePasswordCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Patients/updatePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdatePassword(_response);
        });
    }

    protected processUpdatePassword(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(<any>null);
    }
}

export interface IPatientToursClient {
    skipTour(tourKey: string | null): Promise<FileResponse>;
    finishTour(tourKey: string | null): Promise<FileResponse>;
    shouldStartTour(tourKey: string | null): Promise<boolean>;
}

export class PatientToursClient implements IPatientToursClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    skipTour(tourKey: string | null): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/patients/tours/{tourKey}/skip";
        if (tourKey === undefined || tourKey === null)
            throw new Error("The parameter 'tourKey' must be defined.");
        url_ = url_.replace("{tourKey}", encodeURIComponent("" + tourKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSkipTour(_response);
        });
    }

    protected processSkipTour(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    finishTour(tourKey: string | null): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/patients/tours/{tourKey}/finish";
        if (tourKey === undefined || tourKey === null)
            throw new Error("The parameter 'tourKey' must be defined.");
        url_ = url_.replace("{tourKey}", encodeURIComponent("" + tourKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processFinishTour(_response);
        });
    }

    protected processFinishTour(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    shouldStartTour(tourKey: string | null): Promise<boolean> {
        let url_ = this.baseUrl + "/api/patients/tours/{tourKey}";
        if (tourKey === undefined || tourKey === null)
            throw new Error("The parameter 'tourKey' must be defined.");
        url_ = url_.replace("{tourKey}", encodeURIComponent("" + tourKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processShouldStartTour(_response);
        });
    }

    protected processShouldStartTour(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export interface ITargetRangesClient {
    getPatientTargetRanges(): Promise<PatientTargetRangesVm>;
}

export class TargetRangesClient implements ITargetRangesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getPatientTargetRanges(): Promise<PatientTargetRangesVm> {
        let url_ = this.baseUrl + "/api/TargetRanges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetPatientTargetRanges(_response);
        });
    }

    protected processGetPatientTargetRanges(response: AxiosResponse): Promise<PatientTargetRangesVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PatientTargetRangesVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PatientTargetRangesVm>(<any>null);
    }
}

export interface ITranslationsClient {
    updateTranslationFile(elementName: string | null, language: string | null, file: FileParameter | null | undefined): Promise<FileResponse>;
    getTranslationElements(): Promise<TranslationsVm>;
    getTranslationByElementByLanguage(elementName: string | null, language: string | null): Promise<TranslationVm>;
}

export class TranslationsClient implements ITranslationsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    updateTranslationFile(elementName: string | null, language: string | null, file: FileParameter | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Translations/updatefile/{elementName}/{language}";
        if (elementName === undefined || elementName === null)
            throw new Error("The parameter 'elementName' must be defined.");
        url_ = url_.replace("{elementName}", encodeURIComponent("" + elementName));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdateTranslationFile(_response);
        });
    }

    protected processUpdateTranslationFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getTranslationElements(): Promise<TranslationsVm> {
        let url_ = this.baseUrl + "/api/Translations/elements";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetTranslationElements(_response);
        });
    }

    protected processGetTranslationElements(response: AxiosResponse): Promise<TranslationsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TranslationsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TranslationsVm>(<any>null);
    }

    getTranslationByElementByLanguage(elementName: string | null, language: string | null): Promise<TranslationVm> {
        let url_ = this.baseUrl + "/api/Translations/{elementName}/{language}";
        if (elementName === undefined || elementName === null)
            throw new Error("The parameter 'elementName' must be defined.");
        url_ = url_.replace("{elementName}", encodeURIComponent("" + elementName));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetTranslationByElementByLanguage(_response);
        });
    }

    protected processGetTranslationByElementByLanguage(response: AxiosResponse): Promise<TranslationVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TranslationVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TranslationVm>(<any>null);
    }
}

export class PatientsVm implements IPatientsVm {
    patients?: PatientDto[] | undefined;

    constructor(data?: IPatientsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["patients"])) {
                this.patients = [] as any;
                for (let item of _data["patients"])
                    this.patients!.push(PatientDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatientsVm {
        data = typeof data === 'object' ? data : {};
        let result = new PatientsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.patients)) {
            data["patients"] = [];
            for (let item of this.patients)
                data["patients"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPatientsVm {
    patients?: PatientDto[] | undefined;
}

export class PatientDto implements IPatientDto {
    id?: string;
    emailAddress?: string | undefined;
    activationCode?: string | undefined;
    patientLanguage?: string | undefined;
    timeZone?: string | undefined;
    windowsTimeZone?: string | undefined;
    patientTheme?: string | undefined;
    tooltips?: boolean;
    dateFormat?: string | undefined;
    timeFormat?: string | undefined;
    medicaidNumber?: string | undefined;
    medicareNumber?: string | undefined;
    medicalRecordNumber?: string | undefined;
    insuranceNumber?: string | undefined;
    clinicPatientId?: string;

    constructor(data?: IPatientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailAddress = _data["emailAddress"];
            this.activationCode = _data["activationCode"];
            this.patientLanguage = _data["patientLanguage"];
            this.timeZone = _data["timeZone"];
            this.windowsTimeZone = _data["windowsTimeZone"];
            this.patientTheme = _data["patientTheme"];
            this.tooltips = _data["tooltips"];
            this.dateFormat = _data["dateFormat"];
            this.timeFormat = _data["timeFormat"];
            this.medicaidNumber = _data["medicaidNumber"];
            this.medicareNumber = _data["medicareNumber"];
            this.medicalRecordNumber = _data["medicalRecordNumber"];
            this.insuranceNumber = _data["insuranceNumber"];
            this.clinicPatientId = _data["clinicPatientId"];
        }
    }

    static fromJS(data: any): PatientDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        data["activationCode"] = this.activationCode;
        data["patientLanguage"] = this.patientLanguage;
        data["timeZone"] = this.timeZone;
        data["windowsTimeZone"] = this.windowsTimeZone;
        data["patientTheme"] = this.patientTheme;
        data["tooltips"] = this.tooltips;
        data["dateFormat"] = this.dateFormat;
        data["timeFormat"] = this.timeFormat;
        data["medicaidNumber"] = this.medicaidNumber;
        data["medicareNumber"] = this.medicareNumber;
        data["medicalRecordNumber"] = this.medicalRecordNumber;
        data["insuranceNumber"] = this.insuranceNumber;
        data["clinicPatientId"] = this.clinicPatientId;
        return data;
    }
}

export interface IPatientDto {
    id?: string;
    emailAddress?: string | undefined;
    activationCode?: string | undefined;
    patientLanguage?: string | undefined;
    timeZone?: string | undefined;
    windowsTimeZone?: string | undefined;
    patientTheme?: string | undefined;
    tooltips?: boolean;
    dateFormat?: string | undefined;
    timeFormat?: string | undefined;
    medicaidNumber?: string | undefined;
    medicareNumber?: string | undefined;
    medicalRecordNumber?: string | undefined;
    insuranceNumber?: string | undefined;
    clinicPatientId?: string;
}

export enum PatientQueryFilter {
    AllPatients = 0,
    ActiveOnly = 1,
    InactiveOnly = 2,
}

export class PatientAcceptsToSCommand implements IPatientAcceptsToSCommand {
    patientId?: string;
    password?: string | undefined;

    constructor(data?: IPatientAcceptsToSCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.patientId = _data["patientId"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): PatientAcceptsToSCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PatientAcceptsToSCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientId"] = this.patientId;
        data["password"] = this.password;
        return data;
    }
}

export interface IPatientAcceptsToSCommand {
    patientId?: string;
    password?: string | undefined;
}

export class RegisterPatientCommand implements IRegisterPatientCommand {
    clinicPatientId?: string;
    clinicId?: string;
    clinicSubdomain?: string | undefined;
    emailAddress?: string | undefined;
    givenName?: string | undefined;
    middleName?: string | undefined;
    familyName?: string | undefined;
    patientLanguage?: string | undefined;
    patientTimeZone?: string | undefined;
    patientWindowsTimeZone?: string | undefined;
    phoneNumber?: string | undefined;
    birthDate?: Date | undefined;
    primaryCareProviderId?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zipCode?: string | undefined;
    country?: string | undefined;
    emergencyContactName?: string | undefined;
    emergencyContactPhoneNumber?: string | undefined;
    emergencyContactRelationship?: string | undefined;

    constructor(data?: IRegisterPatientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clinicPatientId = _data["clinicPatientId"];
            this.clinicId = _data["clinicId"];
            this.clinicSubdomain = _data["clinicSubdomain"];
            this.emailAddress = _data["emailAddress"];
            this.givenName = _data["givenName"];
            this.middleName = _data["middleName"];
            this.familyName = _data["familyName"];
            this.patientLanguage = _data["patientLanguage"];
            this.patientTimeZone = _data["patientTimeZone"];
            this.patientWindowsTimeZone = _data["patientWindowsTimeZone"];
            this.phoneNumber = _data["phoneNumber"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.primaryCareProviderId = _data["primaryCareProviderId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zipCode = _data["zipCode"];
            this.country = _data["country"];
            this.emergencyContactName = _data["emergencyContactName"];
            this.emergencyContactPhoneNumber = _data["emergencyContactPhoneNumber"];
            this.emergencyContactRelationship = _data["emergencyContactRelationship"];
        }
    }

    static fromJS(data: any): RegisterPatientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterPatientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clinicPatientId"] = this.clinicPatientId;
        data["clinicId"] = this.clinicId;
        data["clinicSubdomain"] = this.clinicSubdomain;
        data["emailAddress"] = this.emailAddress;
        data["givenName"] = this.givenName;
        data["middleName"] = this.middleName;
        data["familyName"] = this.familyName;
        data["patientLanguage"] = this.patientLanguage;
        data["patientTimeZone"] = this.patientTimeZone;
        data["patientWindowsTimeZone"] = this.patientWindowsTimeZone;
        data["phoneNumber"] = this.phoneNumber;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["primaryCareProviderId"] = this.primaryCareProviderId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["country"] = this.country;
        data["emergencyContactName"] = this.emergencyContactName;
        data["emergencyContactPhoneNumber"] = this.emergencyContactPhoneNumber;
        data["emergencyContactRelationship"] = this.emergencyContactRelationship;
        return data;
    }
}

export interface IRegisterPatientCommand {
    clinicPatientId?: string;
    clinicId?: string;
    clinicSubdomain?: string | undefined;
    emailAddress?: string | undefined;
    givenName?: string | undefined;
    middleName?: string | undefined;
    familyName?: string | undefined;
    patientLanguage?: string | undefined;
    patientTimeZone?: string | undefined;
    patientWindowsTimeZone?: string | undefined;
    phoneNumber?: string | undefined;
    birthDate?: Date | undefined;
    primaryCareProviderId?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zipCode?: string | undefined;
    country?: string | undefined;
    emergencyContactName?: string | undefined;
    emergencyContactPhoneNumber?: string | undefined;
    emergencyContactRelationship?: string | undefined;
}

export class SendPatientOnboardingEmailCommand implements ISendPatientOnboardingEmailCommand {
    patientId?: string;
    clinicPatientId?: string;
    language?: string | undefined;

    constructor(data?: ISendPatientOnboardingEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.patientId = _data["patientId"];
            this.clinicPatientId = _data["clinicPatientId"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): SendPatientOnboardingEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendPatientOnboardingEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientId"] = this.patientId;
        data["clinicPatientId"] = this.clinicPatientId;
        data["language"] = this.language;
        return data;
    }
}

export interface ISendPatientOnboardingEmailCommand {
    patientId?: string;
    clinicPatientId?: string;
    language?: string | undefined;
}

export class EnableMarketingEmailsCommand implements IEnableMarketingEmailsCommand {
    patientId?: string;

    constructor(data?: IEnableMarketingEmailsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.patientId = _data["patientId"];
        }
    }

    static fromJS(data: any): EnableMarketingEmailsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EnableMarketingEmailsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientId"] = this.patientId;
        return data;
    }
}

export interface IEnableMarketingEmailsCommand {
    patientId?: string;
}

export class DisableMarketingEmailsCommand implements IDisableMarketingEmailsCommand {
    patientId?: string;

    constructor(data?: IDisableMarketingEmailsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.patientId = _data["patientId"];
        }
    }

    static fromJS(data: any): DisableMarketingEmailsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DisableMarketingEmailsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientId"] = this.patientId;
        return data;
    }
}

export interface IDisableMarketingEmailsCommand {
    patientId?: string;
}

export class Unit implements IUnit {

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IUnit {
}

export class UpdateEmailAddressCommand implements IUpdateEmailAddressCommand {
    patientId?: string;
    emailAddress?: string | undefined;

    constructor(data?: IUpdateEmailAddressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.patientId = _data["patientId"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): UpdateEmailAddressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmailAddressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientId"] = this.patientId;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface IUpdateEmailAddressCommand {
    patientId?: string;
    emailAddress?: string | undefined;
}

export class CreateObservationCommand implements ICreateObservationCommand {
    observationId?: string;
    clinicPatientId?: string;
    observationCode?: string | undefined;
    effectiveDate?: Date;
    source?: string | undefined;
    observationStatus?: string | undefined;
    observationLevel?: string | undefined;
    isReviewed?: boolean;
    isReviewedDate?: Date | undefined;
    reviewedByName?: string | undefined;
    manufacturer?: string | undefined;
    observationDataList?: ObservationDataItem[] | undefined;

    constructor(data?: ICreateObservationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.observationId = _data["observationId"];
            this.clinicPatientId = _data["clinicPatientId"];
            this.observationCode = _data["observationCode"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.source = _data["source"];
            this.observationStatus = _data["observationStatus"];
            this.observationLevel = _data["observationLevel"];
            this.isReviewed = _data["isReviewed"];
            this.isReviewedDate = _data["isReviewedDate"] ? new Date(_data["isReviewedDate"].toString()) : <any>undefined;
            this.reviewedByName = _data["reviewedByName"];
            this.manufacturer = _data["manufacturer"];
            if (Array.isArray(_data["observationDataList"])) {
                this.observationDataList = [] as any;
                for (let item of _data["observationDataList"])
                    this.observationDataList!.push(ObservationDataItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateObservationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateObservationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["observationId"] = this.observationId;
        data["clinicPatientId"] = this.clinicPatientId;
        data["observationCode"] = this.observationCode;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["source"] = this.source;
        data["observationStatus"] = this.observationStatus;
        data["observationLevel"] = this.observationLevel;
        data["isReviewed"] = this.isReviewed;
        data["isReviewedDate"] = this.isReviewedDate ? this.isReviewedDate.toISOString() : <any>undefined;
        data["reviewedByName"] = this.reviewedByName;
        data["manufacturer"] = this.manufacturer;
        if (Array.isArray(this.observationDataList)) {
            data["observationDataList"] = [];
            for (let item of this.observationDataList)
                data["observationDataList"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateObservationCommand {
    observationId?: string;
    clinicPatientId?: string;
    observationCode?: string | undefined;
    effectiveDate?: Date;
    source?: string | undefined;
    observationStatus?: string | undefined;
    observationLevel?: string | undefined;
    isReviewed?: boolean;
    isReviewedDate?: Date | undefined;
    reviewedByName?: string | undefined;
    manufacturer?: string | undefined;
    observationDataList?: ObservationDataItem[] | undefined;
}

export class ObservationDataItem implements IObservationDataItem {
    id?: string;
    observationCode?: string | undefined;
    value?: number;
    unit?: string | undefined;

    constructor(data?: IObservationDataItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.observationCode = _data["observationCode"];
            this.value = _data["value"];
            this.unit = _data["unit"];
        }
    }

    static fromJS(data: any): ObservationDataItem {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationDataItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["observationCode"] = this.observationCode;
        data["value"] = this.value;
        data["unit"] = this.unit;
        return data;
    }
}

export interface IObservationDataItem {
    id?: string;
    observationCode?: string | undefined;
    value?: number;
    unit?: string | undefined;
}

export class UpdateObservationCommand implements IUpdateObservationCommand {
    observationId?: string;
    observationCode?: string | undefined;
    effectiveDate?: Date;
    observationDataList?: ObservationDataItem[] | undefined;

    constructor(data?: IUpdateObservationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.observationId = _data["observationId"];
            this.observationCode = _data["observationCode"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["observationDataList"])) {
                this.observationDataList = [] as any;
                for (let item of _data["observationDataList"])
                    this.observationDataList!.push(ObservationDataItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateObservationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateObservationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["observationId"] = this.observationId;
        data["observationCode"] = this.observationCode;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        if (Array.isArray(this.observationDataList)) {
            data["observationDataList"] = [];
            for (let item of this.observationDataList)
                data["observationDataList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateObservationCommand {
    observationId?: string;
    observationCode?: string | undefined;
    effectiveDate?: Date;
    observationDataList?: ObservationDataItem[] | undefined;
}

export class CareManagementProgramsVm implements ICareManagementProgramsVm {
    careManagementPrograms?: CareManagementProgramDto[] | undefined;

    constructor(data?: ICareManagementProgramsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["careManagementPrograms"])) {
                this.careManagementPrograms = [] as any;
                for (let item of _data["careManagementPrograms"])
                    this.careManagementPrograms!.push(CareManagementProgramDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CareManagementProgramsVm {
        data = typeof data === 'object' ? data : {};
        let result = new CareManagementProgramsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.careManagementPrograms)) {
            data["careManagementPrograms"] = [];
            for (let item of this.careManagementPrograms)
                data["careManagementPrograms"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICareManagementProgramsVm {
    careManagementPrograms?: CareManagementProgramDto[] | undefined;
}

export class CareManagementProgramDto implements ICareManagementProgramDto {
    id?: string;
    shortName?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICareManagementProgramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shortName = _data["shortName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CareManagementProgramDto {
        data = typeof data === 'object' ? data : {};
        let result = new CareManagementProgramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shortName"] = this.shortName;
        data["name"] = this.name;
        return data;
    }
}

export interface ICareManagementProgramDto {
    id?: string;
    shortName?: string | undefined;
    name?: string | undefined;
}

export class CreateOrganizationCommand implements ICreateOrganizationCommand {
    id?: string;
    name?: string | undefined;
    phone?: string | undefined;
    addressLines?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zipCode?: string | undefined;

    constructor(data?: ICreateOrganizationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.addressLines = _data["addressLines"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.zipCode = _data["zipCode"];
        }
    }

    static fromJS(data: any): CreateOrganizationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["addressLines"] = this.addressLines;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zipCode"] = this.zipCode;
        return data;
    }
}

export interface ICreateOrganizationCommand {
    id?: string;
    name?: string | undefined;
    phone?: string | undefined;
    addressLines?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zipCode?: string | undefined;
}

export class OrganizationsVm implements IOrganizationsVm {
    organizations?: OrganizationDto[] | undefined;

    constructor(data?: IOrganizationsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(OrganizationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationsVm {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrganizationsVm {
    organizations?: OrganizationDto[] | undefined;
}

export class OrganizationDto implements IOrganizationDto {
    id?: string;
    name?: string | undefined;
    addressAddressLines?: string | undefined;
    addressCity?: string | undefined;
    addressState?: string | undefined;
    addressZipCode?: string | undefined;
    addressCountry?: string | undefined;

    constructor(data?: IOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.addressAddressLines = _data["addressAddressLines"];
            this.addressCity = _data["addressCity"];
            this.addressState = _data["addressState"];
            this.addressZipCode = _data["addressZipCode"];
            this.addressCountry = _data["addressCountry"];
        }
    }

    static fromJS(data: any): OrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["addressAddressLines"] = this.addressAddressLines;
        data["addressCity"] = this.addressCity;
        data["addressState"] = this.addressState;
        data["addressZipCode"] = this.addressZipCode;
        data["addressCountry"] = this.addressCountry;
        return data;
    }
}

export interface IOrganizationDto {
    id?: string;
    name?: string | undefined;
    addressAddressLines?: string | undefined;
    addressCity?: string | undefined;
    addressState?: string | undefined;
    addressZipCode?: string | undefined;
    addressCountry?: string | undefined;
}

export class SetPatientCareManagementProgramEnrollmentCommand implements ISetPatientCareManagementProgramEnrollmentCommand {
    clinicPatientId?: string;
    careProgramShortName?: string | undefined;
    isEnrolled?: boolean;

    constructor(data?: ISetPatientCareManagementProgramEnrollmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clinicPatientId = _data["clinicPatientId"];
            this.careProgramShortName = _data["careProgramShortName"];
            this.isEnrolled = _data["isEnrolled"];
        }
    }

    static fromJS(data: any): SetPatientCareManagementProgramEnrollmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetPatientCareManagementProgramEnrollmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clinicPatientId"] = this.clinicPatientId;
        data["careProgramShortName"] = this.careProgramShortName;
        data["isEnrolled"] = this.isEnrolled;
        return data;
    }
}

export interface ISetPatientCareManagementProgramEnrollmentCommand {
    clinicPatientId?: string;
    careProgramShortName?: string | undefined;
    isEnrolled?: boolean;
}

export class CreateProviderCommand implements ICreateProviderCommand {
    id?: string;
    name?: string | undefined;
    type?: string | undefined;
    phone?: string | undefined;
    addressLines?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zipCode?: string | undefined;
    organizationId?: string;

    constructor(data?: ICreateProviderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.phone = _data["phone"];
            this.addressLines = _data["addressLines"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.zipCode = _data["zipCode"];
            this.organizationId = _data["organizationId"];
        }
    }

    static fromJS(data: any): CreateProviderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProviderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["phone"] = this.phone;
        data["addressLines"] = this.addressLines;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zipCode"] = this.zipCode;
        data["organizationId"] = this.organizationId;
        return data;
    }
}

export interface ICreateProviderCommand {
    id?: string;
    name?: string | undefined;
    type?: string | undefined;
    phone?: string | undefined;
    addressLines?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zipCode?: string | undefined;
    organizationId?: string;
}

export class ProvidersVm implements IProvidersVm {
    providers?: ProviderDto[] | undefined;

    constructor(data?: IProvidersVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["providers"])) {
                this.providers = [] as any;
                for (let item of _data["providers"])
                    this.providers!.push(ProviderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProvidersVm {
        data = typeof data === 'object' ? data : {};
        let result = new ProvidersVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.providers)) {
            data["providers"] = [];
            for (let item of this.providers)
                data["providers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProvidersVm {
    providers?: ProviderDto[] | undefined;
}

export class ProviderDto implements IProviderDto {
    id?: string;
    name?: string | undefined;
    addressAddressLines?: string | undefined;
    addressCity?: string | undefined;
    addressState?: string | undefined;
    addressCountry?: string | undefined;
    addressZipCode?: string | undefined;

    constructor(data?: IProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.addressAddressLines = _data["addressAddressLines"];
            this.addressCity = _data["addressCity"];
            this.addressState = _data["addressState"];
            this.addressCountry = _data["addressCountry"];
            this.addressZipCode = _data["addressZipCode"];
        }
    }

    static fromJS(data: any): ProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["addressAddressLines"] = this.addressAddressLines;
        data["addressCity"] = this.addressCity;
        data["addressState"] = this.addressState;
        data["addressCountry"] = this.addressCountry;
        data["addressZipCode"] = this.addressZipCode;
        return data;
    }
}

export interface IProviderDto {
    id?: string;
    name?: string | undefined;
    addressAddressLines?: string | undefined;
    addressCity?: string | undefined;
    addressState?: string | undefined;
    addressCountry?: string | undefined;
    addressZipCode?: string | undefined;
}

export class PatientObservationsVm implements IPatientObservationsVm {
    observations?: PatientObservationDto[] | undefined;

    constructor(data?: IPatientObservationsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["observations"])) {
                this.observations = [] as any;
                for (let item of _data["observations"])
                    this.observations!.push(PatientObservationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatientObservationsVm {
        data = typeof data === 'object' ? data : {};
        let result = new PatientObservationsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.observations)) {
            data["observations"] = [];
            for (let item of this.observations)
                data["observations"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPatientObservationsVm {
    observations?: PatientObservationDto[] | undefined;
}

export class PatientObservationDto implements IPatientObservationDto {
    id?: string;
    observationCode?: string | undefined;
    effectiveDate?: Date;
    source?: string | undefined;
    observationStatus?: string | undefined;
    observationLevel?: string | undefined;
    isReviewed?: boolean;
    isReviewedDate?: Date;
    reviewedByName?: string | undefined;
    manufacturer?: string | undefined;
    change?: string | undefined;
    observationsData?: PatientObservationDataDto[] | undefined;

    constructor(data?: IPatientObservationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.observationCode = _data["observationCode"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.source = _data["source"];
            this.observationStatus = _data["observationStatus"];
            this.observationLevel = _data["observationLevel"];
            this.isReviewed = _data["isReviewed"];
            this.isReviewedDate = _data["isReviewedDate"] ? new Date(_data["isReviewedDate"].toString()) : <any>undefined;
            this.reviewedByName = _data["reviewedByName"];
            this.manufacturer = _data["manufacturer"];
            this.change = _data["change"];
            if (Array.isArray(_data["observationsData"])) {
                this.observationsData = [] as any;
                for (let item of _data["observationsData"])
                    this.observationsData!.push(PatientObservationDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatientObservationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientObservationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["observationCode"] = this.observationCode;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["source"] = this.source;
        data["observationStatus"] = this.observationStatus;
        data["observationLevel"] = this.observationLevel;
        data["isReviewed"] = this.isReviewed;
        data["isReviewedDate"] = this.isReviewedDate ? this.isReviewedDate.toISOString() : <any>undefined;
        data["reviewedByName"] = this.reviewedByName;
        data["manufacturer"] = this.manufacturer;
        data["change"] = this.change;
        if (Array.isArray(this.observationsData)) {
            data["observationsData"] = [];
            for (let item of this.observationsData)
                data["observationsData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPatientObservationDto {
    id?: string;
    observationCode?: string | undefined;
    effectiveDate?: Date;
    source?: string | undefined;
    observationStatus?: string | undefined;
    observationLevel?: string | undefined;
    isReviewed?: boolean;
    isReviewedDate?: Date;
    reviewedByName?: string | undefined;
    manufacturer?: string | undefined;
    change?: string | undefined;
    observationsData?: PatientObservationDataDto[] | undefined;
}

export class PatientObservationDataDto implements IPatientObservationDataDto {
    observationCode?: string | undefined;
    value?: number;
    unit?: string | undefined;

    constructor(data?: IPatientObservationDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.observationCode = _data["observationCode"];
            this.value = _data["value"];
            this.unit = _data["unit"];
        }
    }

    static fromJS(data: any): PatientObservationDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientObservationDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["observationCode"] = this.observationCode;
        data["value"] = this.value;
        data["unit"] = this.unit;
        return data;
    }
}

export interface IPatientObservationDataDto {
    observationCode?: string | undefined;
    value?: number;
    unit?: string | undefined;
}

export class CreateManualObservationCommand implements ICreateManualObservationCommand {
    observationCode?: string | undefined;
    effectiveDate?: Date;
    observationDataList?: ManualObservationDataItem[] | undefined;

    constructor(data?: ICreateManualObservationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.observationCode = _data["observationCode"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["observationDataList"])) {
                this.observationDataList = [] as any;
                for (let item of _data["observationDataList"])
                    this.observationDataList!.push(ManualObservationDataItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManualObservationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManualObservationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["observationCode"] = this.observationCode;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        if (Array.isArray(this.observationDataList)) {
            data["observationDataList"] = [];
            for (let item of this.observationDataList)
                data["observationDataList"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateManualObservationCommand {
    observationCode?: string | undefined;
    effectiveDate?: Date;
    observationDataList?: ManualObservationDataItem[] | undefined;
}

export class ManualObservationDataItem implements IManualObservationDataItem {
    observationCode?: string | undefined;
    value?: number;
    unit?: string | undefined;

    constructor(data?: IManualObservationDataItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.observationCode = _data["observationCode"];
            this.value = _data["value"];
            this.unit = _data["unit"];
        }
    }

    static fromJS(data: any): ManualObservationDataItem {
        data = typeof data === 'object' ? data : {};
        let result = new ManualObservationDataItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["observationCode"] = this.observationCode;
        data["value"] = this.value;
        data["unit"] = this.unit;
        return data;
    }
}

export interface IManualObservationDataItem {
    observationCode?: string | undefined;
    value?: number;
    unit?: string | undefined;
}

export class RecentPatientObservationTypesVm implements IRecentPatientObservationTypesVm {
    observationTypes?: ObservationTypeDto[] | undefined;

    constructor(data?: IRecentPatientObservationTypesVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["observationTypes"])) {
                this.observationTypes = [] as any;
                for (let item of _data["observationTypes"])
                    this.observationTypes!.push(ObservationTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecentPatientObservationTypesVm {
        data = typeof data === 'object' ? data : {};
        let result = new RecentPatientObservationTypesVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.observationTypes)) {
            data["observationTypes"] = [];
            for (let item of this.observationTypes)
                data["observationTypes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRecentPatientObservationTypesVm {
    observationTypes?: ObservationTypeDto[] | undefined;
}

export class ObservationTypeDto implements IObservationTypeDto {
    observationType?: string | undefined;
    observationOrder?: number;

    constructor(data?: IObservationTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.observationType = _data["observationType"];
            this.observationOrder = _data["observationOrder"];
        }
    }

    static fromJS(data: any): ObservationTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["observationType"] = this.observationType;
        data["observationOrder"] = this.observationOrder;
        return data;
    }
}

export interface IObservationTypeDto {
    observationType?: string | undefined;
    observationOrder?: number;
}

export class PatientVm implements IPatientVm {
    id?: string;
    givenName?: string | undefined;
    middleName?: string | undefined;
    familyName?: string | undefined;
    emailAddress?: string | undefined;
    patientLanguage?: string | undefined;
    timeZone?: string | undefined;
    windowsTimeZone?: string | undefined;
    patientTheme?: string | undefined;
    tooltips?: boolean;
    dateFormat?: string | undefined;
    timeFormat?: string | undefined;
    phone?: string | undefined;
    birthDate?: Date | undefined;
    medicaidNumber?: string | undefined;
    medicareNumber?: string | undefined;
    medicalRecordNumber?: string | undefined;
    insuranceNumber?: string | undefined;
    clinicPatientIds?: string[] | undefined;

    constructor(data?: IPatientVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.givenName = _data["givenName"];
            this.middleName = _data["middleName"];
            this.familyName = _data["familyName"];
            this.emailAddress = _data["emailAddress"];
            this.patientLanguage = _data["patientLanguage"];
            this.timeZone = _data["timeZone"];
            this.windowsTimeZone = _data["windowsTimeZone"];
            this.patientTheme = _data["patientTheme"];
            this.tooltips = _data["tooltips"];
            this.dateFormat = _data["dateFormat"];
            this.timeFormat = _data["timeFormat"];
            this.phone = _data["phone"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.medicaidNumber = _data["medicaidNumber"];
            this.medicareNumber = _data["medicareNumber"];
            this.medicalRecordNumber = _data["medicalRecordNumber"];
            this.insuranceNumber = _data["insuranceNumber"];
            if (Array.isArray(_data["clinicPatientIds"])) {
                this.clinicPatientIds = [] as any;
                for (let item of _data["clinicPatientIds"])
                    this.clinicPatientIds!.push(item);
            }
        }
    }

    static fromJS(data: any): PatientVm {
        data = typeof data === 'object' ? data : {};
        let result = new PatientVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["givenName"] = this.givenName;
        data["middleName"] = this.middleName;
        data["familyName"] = this.familyName;
        data["emailAddress"] = this.emailAddress;
        data["patientLanguage"] = this.patientLanguage;
        data["timeZone"] = this.timeZone;
        data["windowsTimeZone"] = this.windowsTimeZone;
        data["patientTheme"] = this.patientTheme;
        data["tooltips"] = this.tooltips;
        data["dateFormat"] = this.dateFormat;
        data["timeFormat"] = this.timeFormat;
        data["phone"] = this.phone;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["medicaidNumber"] = this.medicaidNumber;
        data["medicareNumber"] = this.medicareNumber;
        data["medicalRecordNumber"] = this.medicalRecordNumber;
        data["insuranceNumber"] = this.insuranceNumber;
        if (Array.isArray(this.clinicPatientIds)) {
            data["clinicPatientIds"] = [];
            for (let item of this.clinicPatientIds)
                data["clinicPatientIds"].push(item);
        }
        return data;
    }
}

export interface IPatientVm {
    id?: string;
    givenName?: string | undefined;
    middleName?: string | undefined;
    familyName?: string | undefined;
    emailAddress?: string | undefined;
    patientLanguage?: string | undefined;
    timeZone?: string | undefined;
    windowsTimeZone?: string | undefined;
    patientTheme?: string | undefined;
    tooltips?: boolean;
    dateFormat?: string | undefined;
    timeFormat?: string | undefined;
    phone?: string | undefined;
    birthDate?: Date | undefined;
    medicaidNumber?: string | undefined;
    medicareNumber?: string | undefined;
    medicalRecordNumber?: string | undefined;
    insuranceNumber?: string | undefined;
    clinicPatientIds?: string[] | undefined;
}

export class UpdatePatientPreferencesCommand implements IUpdatePatientPreferencesCommand {
    patientId?: string;
    patientLanguage?: string | undefined;
    timeZone?: string | undefined;
    windowsTimeZone?: string | undefined;
    patientTheme?: string | undefined;
    tooltips?: boolean;
    dateFormat?: string | undefined;
    timeFormat?: string | undefined;

    constructor(data?: IUpdatePatientPreferencesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.patientId = _data["patientId"];
            this.patientLanguage = _data["patientLanguage"];
            this.timeZone = _data["timeZone"];
            this.windowsTimeZone = _data["windowsTimeZone"];
            this.patientTheme = _data["patientTheme"];
            this.tooltips = _data["tooltips"];
            this.dateFormat = _data["dateFormat"];
            this.timeFormat = _data["timeFormat"];
        }
    }

    static fromJS(data: any): UpdatePatientPreferencesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePatientPreferencesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientId"] = this.patientId;
        data["patientLanguage"] = this.patientLanguage;
        data["timeZone"] = this.timeZone;
        data["windowsTimeZone"] = this.windowsTimeZone;
        data["patientTheme"] = this.patientTheme;
        data["tooltips"] = this.tooltips;
        data["dateFormat"] = this.dateFormat;
        data["timeFormat"] = this.timeFormat;
        return data;
    }
}

export interface IUpdatePatientPreferencesCommand {
    patientId?: string;
    patientLanguage?: string | undefined;
    timeZone?: string | undefined;
    windowsTimeZone?: string | undefined;
    patientTheme?: string | undefined;
    tooltips?: boolean;
    dateFormat?: string | undefined;
    timeFormat?: string | undefined;
}

export class Result implements IResult {
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResult {
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class PatientRequestUpdateEmailCommand implements IPatientRequestUpdateEmailCommand {
    patientId?: string;
    password?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: IPatientRequestUpdateEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.patientId = _data["patientId"];
            this.password = _data["password"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): PatientRequestUpdateEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PatientRequestUpdateEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientId"] = this.patientId;
        data["password"] = this.password;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface IPatientRequestUpdateEmailCommand {
    patientId?: string;
    password?: string | undefined;
    emailAddress?: string | undefined;
}

export class EmailTokenVm implements IEmailTokenVm {
    token?: string | undefined;
    tokenExpiration?: Date;
    patientId?: string;
    givenName?: string | undefined;
    familyName?: string | undefined;
    newEmailAddress?: string | undefined;

    constructor(data?: IEmailTokenVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.tokenExpiration = _data["tokenExpiration"] ? new Date(_data["tokenExpiration"].toString()) : <any>undefined;
            this.patientId = _data["patientId"];
            this.givenName = _data["givenName"];
            this.familyName = _data["familyName"];
            this.newEmailAddress = _data["newEmailAddress"];
        }
    }

    static fromJS(data: any): EmailTokenVm {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTokenVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["tokenExpiration"] = this.tokenExpiration ? this.tokenExpiration.toISOString() : <any>undefined;
        data["patientId"] = this.patientId;
        data["givenName"] = this.givenName;
        data["familyName"] = this.familyName;
        data["newEmailAddress"] = this.newEmailAddress;
        return data;
    }
}

export interface IEmailTokenVm {
    token?: string | undefined;
    tokenExpiration?: Date;
    patientId?: string;
    givenName?: string | undefined;
    familyName?: string | undefined;
    newEmailAddress?: string | undefined;
}

export class PatientProfileVm implements IPatientProfileVm {
    patientName?: string | undefined;
    phone?: string | undefined;
    birthDate?: Date | undefined;
    emergencyContact?: EmergencyContactDto | undefined;
    patientPrograms?: PatientCareManagementProgramDto[] | undefined;

    constructor(data?: IPatientProfileVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.patientName = _data["patientName"];
            this.phone = _data["phone"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.emergencyContact = _data["emergencyContact"] ? EmergencyContactDto.fromJS(_data["emergencyContact"]) : <any>undefined;
            if (Array.isArray(_data["patientPrograms"])) {
                this.patientPrograms = [] as any;
                for (let item of _data["patientPrograms"])
                    this.patientPrograms!.push(PatientCareManagementProgramDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatientProfileVm {
        data = typeof data === 'object' ? data : {};
        let result = new PatientProfileVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientName"] = this.patientName;
        data["phone"] = this.phone;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["emergencyContact"] = this.emergencyContact ? this.emergencyContact.toJSON() : <any>undefined;
        if (Array.isArray(this.patientPrograms)) {
            data["patientPrograms"] = [];
            for (let item of this.patientPrograms)
                data["patientPrograms"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPatientProfileVm {
    patientName?: string | undefined;
    phone?: string | undefined;
    birthDate?: Date | undefined;
    emergencyContact?: EmergencyContactDto | undefined;
    patientPrograms?: PatientCareManagementProgramDto[] | undefined;
}

export class EmergencyContactDto implements IEmergencyContactDto {
    contactName?: string | undefined;
    phone?: string | undefined;
    relationship?: string | undefined;

    constructor(data?: IEmergencyContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactName = _data["contactName"];
            this.phone = _data["phone"];
            this.relationship = _data["relationship"];
        }
    }

    static fromJS(data: any): EmergencyContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmergencyContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactName"] = this.contactName;
        data["phone"] = this.phone;
        data["relationship"] = this.relationship;
        return data;
    }
}

export interface IEmergencyContactDto {
    contactName?: string | undefined;
    phone?: string | undefined;
    relationship?: string | undefined;
}

export class PatientCareManagementProgramDto implements IPatientCareManagementProgramDto {
    billingProvider?: ProviderDto2 | undefined;
    careManagementPrograms?: CareManagementProgramDto2[] | undefined;

    constructor(data?: IPatientCareManagementProgramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.billingProvider = _data["billingProvider"] ? ProviderDto2.fromJS(_data["billingProvider"]) : <any>undefined;
            if (Array.isArray(_data["careManagementPrograms"])) {
                this.careManagementPrograms = [] as any;
                for (let item of _data["careManagementPrograms"])
                    this.careManagementPrograms!.push(CareManagementProgramDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatientCareManagementProgramDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientCareManagementProgramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingProvider"] = this.billingProvider ? this.billingProvider.toJSON() : <any>undefined;
        if (Array.isArray(this.careManagementPrograms)) {
            data["careManagementPrograms"] = [];
            for (let item of this.careManagementPrograms)
                data["careManagementPrograms"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPatientCareManagementProgramDto {
    billingProvider?: ProviderDto2 | undefined;
    careManagementPrograms?: CareManagementProgramDto2[] | undefined;
}

export class ProviderDto2 implements IProviderDto2 {
    name?: string | undefined;
    type?: string | undefined;
    phone?: string | undefined;
    addressAddressLines?: string | undefined;
    addressCity?: string | undefined;
    addressState?: string | undefined;
    addressCountry?: string | undefined;
    addressZipCode?: string | undefined;
    organization?: OrganizationDto2 | undefined;

    constructor(data?: IProviderDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.phone = _data["phone"];
            this.addressAddressLines = _data["addressAddressLines"];
            this.addressCity = _data["addressCity"];
            this.addressState = _data["addressState"];
            this.addressCountry = _data["addressCountry"];
            this.addressZipCode = _data["addressZipCode"];
            this.organization = _data["organization"] ? OrganizationDto2.fromJS(_data["organization"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProviderDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["phone"] = this.phone;
        data["addressAddressLines"] = this.addressAddressLines;
        data["addressCity"] = this.addressCity;
        data["addressState"] = this.addressState;
        data["addressCountry"] = this.addressCountry;
        data["addressZipCode"] = this.addressZipCode;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProviderDto2 {
    name?: string | undefined;
    type?: string | undefined;
    phone?: string | undefined;
    addressAddressLines?: string | undefined;
    addressCity?: string | undefined;
    addressState?: string | undefined;
    addressCountry?: string | undefined;
    addressZipCode?: string | undefined;
    organization?: OrganizationDto2 | undefined;
}

export class OrganizationDto2 implements IOrganizationDto2 {
    name?: string | undefined;
    phone?: string | undefined;
    addressAddressLines?: string | undefined;
    addressCity?: string | undefined;
    addressState?: string | undefined;
    addressCountry?: string | undefined;
    addressZipCode?: string | undefined;

    constructor(data?: IOrganizationDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.addressAddressLines = _data["addressAddressLines"];
            this.addressCity = _data["addressCity"];
            this.addressState = _data["addressState"];
            this.addressCountry = _data["addressCountry"];
            this.addressZipCode = _data["addressZipCode"];
        }
    }

    static fromJS(data: any): OrganizationDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["addressAddressLines"] = this.addressAddressLines;
        data["addressCity"] = this.addressCity;
        data["addressState"] = this.addressState;
        data["addressCountry"] = this.addressCountry;
        data["addressZipCode"] = this.addressZipCode;
        return data;
    }
}

export interface IOrganizationDto2 {
    name?: string | undefined;
    phone?: string | undefined;
    addressAddressLines?: string | undefined;
    addressCity?: string | undefined;
    addressState?: string | undefined;
    addressCountry?: string | undefined;
    addressZipCode?: string | undefined;
}

export class CareManagementProgramDto2 implements ICareManagementProgramDto2 {
    name?: string | undefined;

    constructor(data?: ICareManagementProgramDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CareManagementProgramDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new CareManagementProgramDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICareManagementProgramDto2 {
    name?: string | undefined;
}

export class UpdatePasswordCommand implements IUpdatePasswordCommand {
    patientId?: string | undefined;
    currentPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IUpdatePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.patientId = _data["patientId"];
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): UpdatePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientId"] = this.patientId;
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IUpdatePasswordCommand {
    patientId?: string | undefined;
    currentPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class PatientTargetRangesVm implements IPatientTargetRangesVm {
    targetRanges?: TargetRangeDto[] | undefined;

    constructor(data?: IPatientTargetRangesVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["targetRanges"])) {
                this.targetRanges = [] as any;
                for (let item of _data["targetRanges"])
                    this.targetRanges!.push(TargetRangeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatientTargetRangesVm {
        data = typeof data === 'object' ? data : {};
        let result = new PatientTargetRangesVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.targetRanges)) {
            data["targetRanges"] = [];
            for (let item of this.targetRanges)
                data["targetRanges"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPatientTargetRangesVm {
    targetRanges?: TargetRangeDto[] | undefined;
}

export class TargetRangeDto implements ITargetRangeDto {
    observationCode?: string | undefined;
    unit?: string | undefined;
    criticalHigh?: number;
    atRiskHigh?: number;
    atRiskLow?: number;
    criticalLow?: number;

    constructor(data?: ITargetRangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.observationCode = _data["observationCode"];
            this.unit = _data["unit"];
            this.criticalHigh = _data["criticalHigh"];
            this.atRiskHigh = _data["atRiskHigh"];
            this.atRiskLow = _data["atRiskLow"];
            this.criticalLow = _data["criticalLow"];
        }
    }

    static fromJS(data: any): TargetRangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TargetRangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["observationCode"] = this.observationCode;
        data["unit"] = this.unit;
        data["criticalHigh"] = this.criticalHigh;
        data["atRiskHigh"] = this.atRiskHigh;
        data["atRiskLow"] = this.atRiskLow;
        data["criticalLow"] = this.criticalLow;
        return data;
    }
}

export interface ITargetRangeDto {
    observationCode?: string | undefined;
    unit?: string | undefined;
    criticalHigh?: number;
    atRiskHigh?: number;
    atRiskLow?: number;
    criticalLow?: number;
}

export class TranslationsVm implements ITranslationsVm {
    translations?: TranslationDto[] | undefined;

    constructor(data?: ITranslationsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["translations"])) {
                this.translations = [] as any;
                for (let item of _data["translations"])
                    this.translations!.push(TranslationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TranslationsVm {
        data = typeof data === 'object' ? data : {};
        let result = new TranslationsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.translations)) {
            data["translations"] = [];
            for (let item of this.translations)
                data["translations"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITranslationsVm {
    translations?: TranslationDto[] | undefined;
}

export class TranslationDto implements ITranslationDto {
    elementName?: string | undefined;

    constructor(data?: ITranslationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.elementName = _data["elementName"];
        }
    }

    static fromJS(data: any): TranslationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TranslationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elementName"] = this.elementName;
        return data;
    }
}

export interface ITranslationDto {
    elementName?: string | undefined;
}

export class TranslationVm implements ITranslationVm {
    elementName?: string | undefined;
    language?: string | undefined;
    fileContent?: string | undefined;

    constructor(data?: ITranslationVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.elementName = _data["elementName"];
            this.language = _data["language"];
            this.fileContent = _data["fileContent"];
        }
    }

    static fromJS(data: any): TranslationVm {
        data = typeof data === 'object' ? data : {};
        let result = new TranslationVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elementName"] = this.elementName;
        data["language"] = this.language;
        data["fileContent"] = this.fileContent;
        return data;
    }
}

export interface ITranslationVm {
    elementName?: string | undefined;
    language?: string | undefined;
    fileContent?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}
